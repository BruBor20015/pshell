#!/usr/bin/python

#################################################################################
# 
# Copyright (c) 2009, Ron Iovine, All rights reserved.  
#  
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of Ron Iovine nor the names of its contributors 
#       may be used to endorse or promote products derived from this software 
#       without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY Ron Iovine ''AS IS'' AND ANY EXPRESS OR 
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
# IN NO EVENT SHALL Ron Iovine BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
# IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
# POSSIBILITY OF SUCH DAMAGE. 
#
#################################################################################

################################################################################
#
# logProfiler:
#
# This program will provide the ability to perform code performance analysis
# based on a logfile that was generated by programs that instrument their code
# with trace log statements that use a file, function, line, and timestamp
#
# This profiler understands logfile entries of the following formats:
#
# app | level | 14:40:32.377256 | file(function):line | user-message
# app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
# 2014-08-17 23:11:00.114 level [app:file:line] user-message
# 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
# 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
#
# Modify the functions 'parseLine' and 'findApp' to add additional log 
# entry formats
#
################################################################################

# import all our necessary modules
import sys
import re
import os
import datetime
import operator

##############################
#
# global data
#
##############################

# modify the following items for different trace log line formats
gTimestampFormat = "%H:%M:%S.%f"

# modify to use the desired keep alive indication,
# valid values are 'lines', 'wheel', 'dots', and 'none'
gKeepAliveType = "lines"

# display formatting constants
gBanner = "LOGFILE PROFILER"
gBannerLength = len(gBanner)

gAreaLabel1 = "START CODE AREA"
gMinArea1Width = len(gAreaLabel1)

gAreaLabel2 = "END CODE AREA"
gMinArea2Width = len(gAreaLabel2)

gCountLabel = "COUNT"
gCountLabelLength = len(gCountLabel)+1

gTotTimeLabel = "TOT TIME"
gMaxTimeLabel = "MAX TIME"
gMinTimeLabel = "MIN TIME"
gAvgTimeLabel = "AVG TIME"
gMedTimeLabel = "MED TIME"
gStdDevLabel = "STD DEV"
gLabelSuffix = ""

gTimeDeltaLength = 14
gTimeDeltaCount = 6

gUnderline = "="

gSpaceLength = 2

gNormalDisplayColumns = 11
gNormalDisplayPadLength = gSpaceLength*(gNormalDisplayColumns-1)

gTotalLines = 0
gClearStatusUpdate = "\r"

gTimestampEndings = (']', '|', ' ')
gTimestampPositions = {0, 1, 3, 4}
gTimestampFormat = "%H:%M:%S.%f"
gTimestampRegexp0 = '\d{2}:\d{2}:\d{2}.\d{3}'
gTimestampRegexp1 = '\d{2}:\d{2}:\d{2}.\d{4}'
gTimestampRegexp2 = '\d{2}:\d{2}:\d{2}.\d{5}'
gTimestampRegexp3 = '\d{2}:\d{2}:\d{2}.\d{6}'
gTimestampRegexp4 = '\d{4}-\d{2}-\d{2}Td{2}:\d{2}:\d{2}.\d{5}'
gGreen = "\33[0;32m"
gRed = "\33[0;31m"
gAmber = "\33[0;33m"
gHighlight = gAmber
gNormal = "\33[0m"

# various keep alive global variables
gValidKeepAliveTypes = ('wheel', 'dots', 'lines', 'none')
gWheel = ('|', '/', '-', '\\')
gWheelIndex = 0

# command line option switches and default values
gValidOptions = ('-tot', '-min', '-max', '-avg', '-med', '-std', '-count')
gValidDiffs = ('percent', 'time')
gDiffRequested = False
gTimeSuffix = ""
gTimeWidthAdjust = 0
gCountSuffix = ""
gCountWidthAdjust = 0
gTotalRunTime = datetime.timedelta(0)
gTotalProfiledTime = datetime.timedelta(0)
gMaxTimeDeltaDiff = 0.0
gMinTimeDeltaDiff = sys.float_info.max
gDisplayAll = "all"
gNoFilter = "none"
gNoOption = "none"
gMaxAreaWidth1 = 0
gMaxAreaWidth2 = 0

# global profile lists
gProfiles1 = []
gProfiles2 = []
gProfilesDiff = []

#####################################################
#
# display the program usage
#
#####################################################
def showUsage():
  print("")
  print("Usage: logProfiler [-tot | -min | -max | -avg | -med | -std | -count]")
  print("                   [num=<count>] [app=<id>] [file=<name>] [func=<name>] [out=<outfile>] [diff=<type>] [delta=<time>]")
  print("                   <logfile1> [<logfile2>...<logfileN>]")
  print("")
  print("  This program will provide the ability to perform code performance analysis")
  print("  based on a logfile that was generated by programs that instrument their code")
  print("  with trace log statements that use a file, function, line, and timestamp")
  print("")
  print("  where:")
  print("    -tot      : Sort highest to lowest total time")
  print("    -min      : Sort highest to lowest minimum time")
  print("    -max      : Sort highest to lowest maximum time")
  print("    -avg      : Sort highest to lowest average time")
  print("    -med      : Sort highest to lowest median time")
  print("    -std      : Sort highest to lowest standard deviation time")
  print("    -count    : Sort highest to lowest occurance count")
  print("    num       : Specify number of entries to display")
  print("    app       : Specify an app filter (process name or pid)")
  print("    file      : Specify a file name display filter")
  print("    func      : Specify a function name display filter")
  print("    out       : Specify an output file to write the results")
  print("    diff      : Compute diff between logfile1 and logfile2 profiles")
  print("    delta     : Show all areas that are >= specified time")
  print("    <count>   : The number of entries to display")
  print("    <id>      : Name or PID of app to filter")
  print("    <name>    : Name (or substring) of file/function display filter")
  print("    <type>    : The desired diff type, valid values are 'percent' and 'time'")
  print("    <time>    : The time delta in seconds (float)")
  print("    <outfile> : Name of the output file to write the results")
  print("    <logfile> : Trace log file to profile")
  print("")
  print("  NOTES:")
  print("")
  print("    If doing a non-diff profile, as many logfiles can be given as desired,")
  print("    for a 'diff' based profile, exactly two logfiles must be given, for a")
  print("    time 'delta' based analysis, only one logfile should be provided.")
  print("")
  print("    Use the 'app' filter when working with logfiles that contain logs from")
  print("    multiple apps, e.g. syslog etc.")
  print("")
  print("    This program will currently work with log entries of the following formats:")
  print("")
  print("    app | level | 14:40:32.377256 | file(function):line | user-message")
  print("    app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message ")
  print("    2014-08-17 23:11:00.114 level [app:file:line] user-message")
  print("    2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message")
  print("    2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message")
  print("")
  print("    Modify the functions 'parseLine' and 'findApp' to add additional log entry formats")
  print("")
  sys.exit()

#####################################################
#
# print a keep alive indicator
#
#####################################################
def printKeepAlive(numLines, type):
  global gWheel
  global gWheelIndex
  global gClearStatusUpdate
  global gTotalLines
  if (type == "wheel"):
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*17, " "*17, "\b"*17))
      sys.stdout.flush()
    if ((numLines % 1000) == 0):
      sys.stdout.write("%s\b" % gWheel[gWheelIndex])
      sys.stdout.flush()
      gWheelIndex += 1
      gWheelIndex = gWheelIndex % len(gWheel)
  elif (type == "dots"):
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*20, " "*20, "\b"*20))
      sys.stdout.flush()
    if ((numLines % 5000) == 0):
      sys.stdout.write(".")
      sys.stdout.flush()
  elif (type == "lines"):
    gClearStatusUpdate = "\n\n"
    sys.stdout.write("%s of %s%s" % (str(numLines+1).ljust(len(str(gTotalLines))), gTotalLines, "\b"*(len(str(gTotalLines))*2+4)))
    sys.stdout.flush()
  else:
    if (numLines == 0):
      sys.stdout.write("%s%s%s" % ("\b"*17, " "*17, "\b"*17))
      sys.stdout.flush()

#####################################################
#
# convert a timedelta time to seconds
#
#####################################################
def timeDeltaToSec(timeDelta):
  return float(timeDeltaToUsec(timeDelta) / 1000000.0)

#####################################################
#
# convert a timedelta time to microseconds
#
#####################################################
def timeDeltaToUsec(timeDelta):
  return abs(timeDelta.microseconds + (timeDelta.seconds + timeDelta.days * 86400) * 1000000)

#####################################################
#
# calculated the median times for all the profiles
#
#####################################################
def calculateMedian(profiles):
  for profile in profiles:
    profile["delta"].sort()
    if (len(profile["delta"]) == 1):
      profile["med"] = profile["delta"][0]
    elif (len(profile["delta"])%2 == 0):
      timeDelta1 = profile["delta"][len(profile["delta"])/2-1]
      timeDelta2 = profile["delta"][len(profile["delta"])/2]
      profile["med"] = (timeDelta1+timeDelta2)/2
    else:
      profile["med"] = profile["delta"][len(profile["delta"])/2]

#########################################################
#
# calculated the standard deviation for all the profiles
#
#########################################################
def calculateStdDeviation(profiles):
  for profile in profiles:
    sumDiffSquared = 0.0
    for timeDelta in profile["delta"]:
      sumDiffSquared = (timeDeltaToUsec(timeDelta)-timeDeltaToUsec(profile["avg"]))**2 + sumDiffSquared
    profile["stdDev"] = datetime.timedelta(microseconds=((sumDiffSquared)/len(profile["delta"]))**(1.0/2.0))

#####################################################
#
# find a profile based on filename/function
#
#####################################################
def findProfile(profiles, filename1, function1, line1, filename2, function2, line2):
  for profile in profiles:
    if ((profile["file1"] == filename1) and (profile["function1"] == function1) and (profile["line1"] == line1) and
        (profile["file2"] == filename2) and (profile["function2"] == function2) and (profile["line2"] == line2)):
      return (profile)
  return (None)

######################################################################
#
# return the file, function, line, and timestamp from the input line
#
######################################################################
def parseLine(line):
  
  # change this line parsing function for different log line formats,
  # we need to extract the file, function, line, and timestamp, an
  # example of the currently parsed log line formats are:
  #
  # app | level | 14:40:32.377256 | file(function):line | user-message
  # app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  # 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  # 2014-08-17 23:11:00.114 level [app:file:line] user-message
  # 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  #

  # parse format: 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  expectedNumTokens = 8
  timestampTokenPos = 2
  functionTokenPos = 6
  locationTokenPos = 7
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split("@")
    if ((timestamp != "") and (len(location) == 2)):
      filename = location[0]
      line = location[1][:-1]
      function = tokens[functionTokenPos].strip().split(":")[0]
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  expectedNumTokens = 6
  timestampTokenPos = 0
  functionTokenPos = 4
  locationTokenPos = 5
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split("@")
    if ((timestamp != "") and (len(location) == 2)):
      filename = location[0]
      line = location[1][:-1]
      function = tokens[functionTokenPos].strip().split(":")[0]
      return (filename, "("+function+")", ":"+line, timestamp)

  # parse format: app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  expectedNumTokens = 6
  timestampTokenPos = 1
  filenameTokenPos = 2
  lineTokenPos = 3
  functionTokenPos = 4
  tokens = line.split("|")
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    if (timestamp != ""):
      filename = os.path.basename(tokens[filenameTokenPos].strip())
      line = tokens[lineTokenPos].strip()
      function = tokens[functionTokenPos].strip()
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: app | level | 14:40:32.377256 | file(function):line | user-message
  expectedNumTokens = 5
  timestampTokenPos = 2
  filenameTokenPos = 3
  lineTokenPos = filenameTokenPos
  functionTokenPos = filenameTokenPos
  tokens = line.split("|")
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    if (timestamp != ""):
      filename = tokens[filenameTokenPos].strip().split("(")[0]
      line = tokens[lineTokenPos].strip().split(":")[-1]
      function = tokens[functionTokenPos].strip().split("(")[-1]
      function = function.split(")")[0]
      return (filename, "("+function+")", ":"+line, timestamp)
  
  # parse format: 2014-08-17 23:11:00.114 level [app:file:line] user-message
  expectedNumTokens = 4
  timestampTokenPos = 1
  locationTokenPos = 3
  tokens = line.split()
  if (len(tokens) >= expectedNumTokens):
    timestamp = findTimestamp(tokens[timestampTokenPos].strip())
    location = tokens[locationTokenPos].strip().split(":")
    if ((timestamp != "") and (len(location) == 3)):
      filename = location[1]
      line = location[2][:-1]
      # this format does not have a function, so we just return ""
      return (filename, "", ":"+line, timestamp)
  
  # dropped through, return nothing
  return (None, None, None, None)
  
######################################################################
#
# return true if line matches app filter
#
######################################################################
def findApp(line):
  global gAppFilter
  global gNoFilter
  
  # change this line parsing function for different log line formats,
  # we need to extract the file, function, line, and timestamp, an
  # example of the currently parsed log line formats are:
  #
  # app | level | 14:40:32.377256 | file(function):line | user-message
  # app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
  # 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
  # 2014-08-17 23:11:00.114 level [app:file:line] user-message
  # 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
  #

  if (gAppFilter != gNoFilter):

    # parse format: 2017-10-16T10:38:11.419563 level 2017-10-16T10:38:11.418026 level hostname: app: function: file@line: user-message
    expectedNumTokens = 8
    appTokenPos = 5
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip().split(":")[0]
      if (app == gAppFilter):
        return (True)
  
    # parse format: 2017-10-12T09:26:04.31081 level hostname: app: function: file@line: user-message
    expectedNumTokens = 6
    appTokenPos = 3
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip().split(":")[0]
      if (app == gAppFilter):
        return (True)

    # parse format: app | Sat Nov 23 04:02:35.005624 | file | line | function | level | user-message 
    expectedNumTokens = 6
    appTokenPos = 0
    tokens = line.split("|")
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip()
      if (app == gAppFilter):
        return (True)
  
    # parse format: app | level | 14:40:32.377256 | file(function):line | user-message
    expectedNumTokens = 5
    appTokenPos = 0
    tokens = line.split("|")
    if (len(tokens) >= expectedNumTokens):
      app = tokens[appTokenPos].strip()
      if (app == gAppFilter):
        return (True)
  
    # parse format: 2014-08-17 23:11:00.114 level [app:file:line] user-message
    expectedNumTokens = 4
    locationTokenPos = 3
    tokens = line.split()
    if (len(tokens) >= expectedNumTokens):
      location = tokens[locationTokenPos].strip().split(":")
      app = location[0][1:]
      if (app == gAppFilter):
        return (True)
  
    # dropped through, return nothing
    return (False)
  
  else:
    return (True)

######################################################
#
# update an existing area profile or create a new one
#
######################################################
def updateProfile(profiles, prevLine, currLine):
  
  global gTotalProfiledTime
  global gMaxAreaWidth1
  global gMaxAreaWidth2
  
  (filename1, function1, line1, timestamp1) = parseLine(prevLine)
  (filename2, function2, line2, timestamp2) = parseLine(currLine)
  
  if ((filename1 != None) and (filename2 != None)):
  
    # both lines are good, now either update an existing area profile, or create a new one
    currTime = datetime.datetime.strptime(timestamp2, gTimestampFormat)
    prevTime = datetime.datetime.strptime(timestamp1, gTimestampFormat)
    timeDelta = currTime - prevTime
    # filter out any negative timeDelta, this could happen if the system time
    # has changed during the creation of a logfile or at the midnight rollover
    if (timeDelta >= datetime.timedelta(0)):
      profile = findProfile(profiles, filename1, function1, line1, filename2, function2, line2)
      if (profile == None):
        # create new profile
        areaWidth1 = len(filename1)+len(function1)+len(line1)
        areaWidth2 = len(filename2)+len(function2)+len(line2)
        profiles.append({"file1":filename1,
                         "function1":function1,
                         "line1":line1,
                         "areaWidth1":areaWidth1,
                         "file2":filename2,
                         "function2":function2,
                         "line2":line2,
                         "areaWidth2":areaWidth2,
                         "count":0,
                         "tot":datetime.timedelta(0),
                         "min":datetime.timedelta.max,
                         "max":datetime.timedelta.min,
                         "avg":datetime.timedelta(0),
                         "med":datetime.timedelta(0),
                         "stdDev":datetime.timedelta(0),
                         "delta":[]})
        profile = profiles[-1]
        if (areaWidth1 > gMaxAreaWidth1):
          gMaxAreaWidth1 = areaWidth1
        if (areaWidth2 > gMaxAreaWidth2):
          gMaxAreaWidth2 = areaWidth2
      profile["count"] += 1
      profile["tot"] += timeDelta
      gTotalProfiledTime += timeDelta
      profile["avg"] = profile["tot"]/profile["count"]
      profile["delta"].append(timeDelta)
      if (timeDelta > profile["max"]):
        profile["max"] = timeDelta
      if (timeDelta < profile["min"]):
        profile["min"] = timeDelta

#####################################################
#
# creates the specified profile
#
#####################################################
def createProfile(logfile, profiles):
  global gTotalLines
  global gKeepAliveType
  global gTimestampFormat
  global gTotalRunTime
  lastTimestamp = datetime.timedelta(0)
  firstTimestamp = datetime.timedelta(0)
  if (os.path.isfile(logfile)):
    file = open(logfile, 'r')
    print("")
    sys.stdout.write("Creating run time profile from logfile: %s, please wait...processing line: " % logfile)
    if (gKeepAliveType == "lines"):
      # if we are showing the lines processed keep alive, make an initial
      # pass of the file so we can sount the total number of lines
      gTotalLines = 0
      for line in file:
        gTotalLines += 1
      file.seek(0)
    numLines = 0
    currLine = None
    prevLine = None
    currTimestamp = ""
    for line in file:
      printKeepAlive(numLines, gKeepAliveType)
      if (findApp(line) == True):
        if (currTimestamp != ""):
          prevLine = currLine
        currLine = line
        currTimestamp = findTimestamp(currLine)
        if ((numLines > 0) and (currTimestamp != "") and (prevLine != None)):
          updateProfile(profiles, prevLine, currLine)
      numLines += 1
    gTotalRunTime = lastTimestamp - firstTimestamp
    calculateMedian(profiles)
    calculateStdDeviation(profiles)
    return (True)
  else:
    print("ERROR: logfile: '%s' not found..." % logfile)
    return (False)

#####################################################
#
# shows time display
#
#####################################################
def getTimeDisplay(time, labelLength):
  global gTimeSuffix
  global gTimeWidthAdjust
  global gDiffRequested
  global gDiffType
  # make the display of a 0 time display the microseconds part,
  # a 0 time delta does not display the microseconds by default
  if (time == datetime.timedelta(0)):
    time = "0:00:00.000000"
  if (gDiffRequested):
    if (gDiffType == "percent"):
      width = 10
    else:
      width = 9
    if (time > 0):
      return (("+"+str(time)).rjust(width)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)
    else:
      return (str(time).rjust(width)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)
  else:
    return (str(time)+gTimeSuffix).rjust(labelLength-gTimeWidthAdjust)

#####################################################
#
# shows counts display
#
#####################################################
def getCountDisplay(count, labelLength):
  global gCountSuffix
  global gCountWidthAdjust
  global gDiffRequested
  if (gDiffRequested):
    if (count > 0):
      return (("+"+str(count)).rjust(8)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)
    else:
      return (str(count).rjust(8)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)
  else:
    return (str(count).ljust(labelLength)+gCountSuffix).rjust(labelLength-gCountWidthAdjust)

#####################################################
#
# shows the current profile
#
#####################################################
def showProfile(logfile, outfile, option, count, fileFilter, functionFilter, profiles):
  global gBanner
  global gBannerLength

  global gCountLabel
  global gCountLabelLength

  global gTotTimeLabel
  global gMaxTimeLabel
  global gMinTimeLabel
  global gAvgTimeLabel
  global gMedTimeLabel
  global gStdDevLabel
  global gLabelSuffix

  global gTimeDeltaLength
  global gTimeDeltaCount

  global gUnderline

  global gSpaceLength

  global gNormalDisplayPadLength
  global gMismatchDisplayPadLength

  global gNoFilter
  global gAppFilter  
  global gDisplayAll
  global gClearStatusUpdate

  global gTotalRunTime
  global gDiffRequested
  
  global gAreaLabel1
  global gAreaLabel2
  
  global gMinAreaWidth1
  global gMinAreaWidth2

  global gMaxAreaWidth1
  global gMaxAreaWidth2

  totalDisplayedTime = datetime.timedelta(0)
  gCountLabelLength = gCountLabelLength + len(gLabelSuffix)

  if (outfile == "none"):
    file = sys.stdout
  else:
    file = open(outfile, "w+")
    gClearStatusUpdate = "\n"

  # see if we need to sort our profile
  if (option == "-max"):
    profiles.sort(key=operator.itemgetter('max'), reverse=True)
  elif (option == "-min"):
    profiles.sort(key=operator.itemgetter('min'), reverse=True)
  elif (option == "-avg"):
    profiles.sort(key=operator.itemgetter('avg'), reverse=True)
  elif (option == "-med"):
    profiles.sort(key=operator.itemgetter('med'), reverse=True)
  elif (option == "-std"):
    profiles.sort(key=operator.itemgetter('stdDev'), reverse=True)
  elif (option == "-tot"):
    profiles.sort(key=operator.itemgetter('tot'), reverse=True)
  elif (option == "-count"):
    profiles.sort(key=operator.itemgetter('count'), reverse=True)

  maxAreaWidth1 = gMinArea1Width
  maxAreaWidth2 = gMinArea2Width
  if ((count != gDisplayAll) or (fileFilter != gNoFilter) or (functionFilter != gNoFilter)):
    numDisplayed = 0
    for profile in profiles:
      if ((((fileFilter == gNoFilter) and (functionFilter == gNoFilter)) or
           ((fileFilter != gNoFilter) and (functionFilter == gNoFilter) and ((fileFilter in profile["file1"]) or (fileFilter in profile["file2"]))) or
           ((functionFilter != gNoFilter) and (fileFilter == gNoFilter) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))) or
           (((fileFilter in profile["file1"]) or (fileFilter in profile["file2"])) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))))):
        numDisplayed += 1
        maxAreaWidth1 = max(maxAreaWidth1, profile["areaWidth1"])
        maxAreaWidth2 = max(maxAreaWidth2, profile["areaWidth2"])
      if ((count != gDisplayAll) and (numDisplayed >= int(count))):
        break
  else:
    # we're displaying everything
    maxAreaWidth1 = gMaxAreaWidth1
    maxAreaWidth2 = gMaxAreaWidth2

  # display our header
  maxFieldWidth = maxAreaWidth1 + \
                  maxAreaWidth2 + \
                  gCountLabelLength + \
                  gTimeDeltaLength*gTimeDeltaCount + \
                  gNormalDisplayPadLength
  file.write("%s%s\n" % (gClearStatusUpdate, gBanner.center(maxFieldWidth)))
  if (gAppFilter != gNoFilter):
    logfile = logfile + "(" + gAppFilter + ")"
  file.write("%s\n" % (gUnderline*max(len(logfile), gBannerLength)).center(maxFieldWidth))
  file.write("%s\n" % logfile.center(maxFieldWidth))
  file.write("\n")
  file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (gAreaLabel1.ljust(maxAreaWidth1),
                                                       ' '.ljust(gSpaceLength),
                                                       gAreaLabel2.ljust(maxAreaWidth2),
                                                       ' '.ljust(gSpaceLength),
                                                       (gCountLabel+gLabelSuffix).ljust(gCountLabelLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gTotTimeLabel+gLabelSuffix).ljust(gTimeDeltaLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMaxTimeLabel+gLabelSuffix).ljust(gTimeDeltaLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMinTimeLabel+gLabelSuffix).ljust(gTimeDeltaLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gMedTimeLabel+gLabelSuffix).ljust(gTimeDeltaLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gAvgTimeLabel+gLabelSuffix).ljust(gTimeDeltaLength),
                                                       ' '.ljust(gSpaceLength),
                                                       (gStdDevLabel+gLabelSuffix).ljust(gTimeDeltaLength)))
  file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (gUnderline.ljust(maxAreaWidth1, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(maxAreaWidth2, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gCountLabelLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline),
                                                       ' '.ljust(gSpaceLength),
                                                       gUnderline.ljust(gTimeDeltaLength, gUnderline)))
  # display our profile
  numDisplayed = 0
  for profile in profiles:
    if ((((fileFilter == gNoFilter) and (functionFilter == gNoFilter)) or
         ((fileFilter != gNoFilter) and (functionFilter == gNoFilter) and ((fileFilter in profile["file1"]) or (fileFilter in profile["file2"]))) or
         ((functionFilter != gNoFilter) and (fileFilter == gNoFilter) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))) or
         (((fileFilter in profile["file1"]) or (fileFilter in profile["file2"])) and ((functionFilter in profile["function1"]) or (functionFilter in profile["function2"]))))):
      numDisplayed += 1
      if (not gDiffRequested):
        totalDisplayedTime += profile["tot"]
      area1 = profile["file1"] + profile["function1"] + str(profile["line1"])
      area2 = profile["file2"] + profile["function2"] + str(profile["line2"])
      file.write("%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n" % (area1.ljust(maxAreaWidth1),
                                                           ' '.ljust(gSpaceLength),
                                                           area2.ljust(maxAreaWidth2),
                                                           ' '.ljust(gSpaceLength),
                                                           getCountDisplay(profile["count"], gCountLabelLength).ljust(gCountLabelLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["tot"], gTimeDeltaLength).ljust(gTimeDeltaLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["max"], gTimeDeltaLength).ljust(gTimeDeltaLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["min"], gTimeDeltaLength).ljust(gTimeDeltaLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["med"], gTimeDeltaLength).ljust(gTimeDeltaLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["avg"], gTimeDeltaLength).ljust(gTimeDeltaLength),
                                                           ' '.ljust(gSpaceLength),
                                                           getTimeDisplay(profile["stdDev"], gTimeDeltaLength).ljust(gTimeDeltaLength)))
    if ((count != gDisplayAll) and (numDisplayed >= int(count))):
      break
  if (outfile != "none"):
    print("")
    print("")
    print("Results written to output file: %s" % outfile)
    print("")
  file.write("\n")
  if (not gDiffRequested):
    file.write("\n")
    file.write("RESULTS SUMMARY:\n")
    file.write("%s\n" % gUnderline.ljust(34, gUnderline))
    file.write("Logfile         : %s\n" % logfile)
    file.write("Profiled Time   : %s\n" % str(gTotalProfiledTime))
    file.write("Displayed Time  : %s\n" % str(totalDisplayedTime))
    file.write("Total Areas     : %s\n" % len(profiles))
    file.write("Displayed Areas : %d\n" % numDisplayed)
    file.write("\n")

#####################################################
#
# returns the diff between two time deltas
#
#####################################################
def getTimedeltaDiff(timedelta1, timedelta2):
  global gDiffType
  if (timedelta1 > timedelta2):
    if (gDiffType == "percent"):
      return -round((float(timeDeltaToUsec(timedelta1)-timeDeltaToUsec(timedelta2))/float(timeDeltaToUsec(timedelta1))*100.0), 1)
    else:  # diffType == "time"
      return -int(timeDeltaToUsec(timedelta1)-timeDeltaToUsec(timedelta2))
  elif (timedelta2 > timedelta1):
    if (gDiffType == "percent"):
      if (timeDeltaToUsec(timedelta1) > 0):
        return round((float(timeDeltaToUsec(timedelta2)-timeDeltaToUsec(timedelta1))/float(timeDeltaToUsec(timedelta1))*100.0), 1)
      else:
        return "Infinity"
    else:  # diffType == "time"
      return int(timeDeltaToUsec(timedelta2)-timeDeltaToUsec(timedelta1))
  else:
    if (gDiffType == "percent"):
      return 0.0
    else:  # diffType == "time"
      return 0

#####################################################
#
# returns the diff between two count counts
#
#####################################################
def getCountsDiff(count1, count2):
  global gDiffType
  if (count1 > count2):
    if (gDiffType == "percent"):
      return -round(((float(count1-count2)/float(count1))*100.0), 1)
    else:  # diffType == "time"
      return -int(count1-count2)
  elif (count2 > count1):
    if (gDiffType == "percent"):
      if (count1 > 0):
        return round(((float(count2-count1)/float(count1))*100.0), 1)
      else:
        return "Infinity"
    else:  # diffType == "time"
      return int(count2-count1)
  else:
    if (gDiffType == "percent"):
      return 0.0
    else:  # diffType == "time"
      return 0

#####################################################
#
# calculate the diffs between two profiles
#
#####################################################
def diffProfiles(profiles1, profiles2):
  global gDiffType
  global gProfilesDiff
  global gLabelSuffix
  global gTimeSuffix
  global gTimeWidthAdjust
  global gCountSuffix
  global gCountWidthAdjust
  if (gDiffType == "percent"):
    gLabelSuffix = " %diff"
    gTimeSuffix = "%"
    gCountSuffix = "%"
    gTimeWidthAdjust = 5
    gCountWidthAdjust = 5
  else:  # diffType == "time"
    gLabelSuffix = " diff"
    gTimeSuffix = " Usec"
    gTimeWidthAdjust = 3
    gCountWidthAdjust = 5
  for profile1 in profiles1:
    profile2 = findProfile(profiles2, 
                           profile1["file1"], profile1["function1"], profile1["line1"], 
                           profile1["file2"], profile1["function2"], profile1["line2"])
    if (profile2 != None):
      gProfilesDiff.append({"file1":profile1["file1"],
                            "function1":profile1["function1"],
                            "line1":profile1["line1"],
                            "areaWidth1":profile1["areaWidth1"],
                            "file2":profile1["file2"],
                            "function2":profile1["function2"],
                            "line2":profile1["line2"],
                            "areaWidth2":profile1["areaWidth2"],
                            "count":getCountsDiff(profile1["count"], profile2["count"]),
                            "tot":getTimedeltaDiff(profile1["tot"], profile2["tot"]),
                            "min":getTimedeltaDiff(profile1["min"], profile2["min"]),
                            "max":getTimedeltaDiff(profile1["max"], profile2["max"]),
                            "avg":getTimedeltaDiff(profile1["avg"], profile2["avg"]),
                            "med":getTimedeltaDiff(profile1["med"], profile2["med"]),
                            "stdDev":getTimedeltaDiff(profile1["stdDev"], profile2["stdDev"])})

#####################################################
#
# find the timestamp from the input line
#
#####################################################
def findTimestamp(line):
  global gTimestampEndings
  global gTimestampPositions
  global gTimestampRegexp0
  global gTimestampRegexp1
  global gTimestampRegexp2
  global gTimestampRegexp3
  global gTimestampRegexp4
  timestamp = line.split()
  for position in gTimestampPositions:
    if ((len(timestamp) > position) and (":" in timestamp[position])):
      if (timestamp[position][-1] in gTimestampEndings):
        timestamp = timestamp[position][:-1].strip()
      else:
        timestamp = timestamp[position].strip()
      if ('T' in timestamp):
        timestamp = timestamp.split("T")[-1]
      if (re.match(gTimestampRegexp0, timestamp) or
          re.match(gTimestampRegexp1, timestamp) or
          re.match(gTimestampRegexp2, timestamp) or
          re.match(gTimestampRegexp3, timestamp)):
        return (timestamp)
  return ("")

#######################################################
#
# show all areas whose time delta is >= specified time
#
#######################################################
def createDelta(logfile, maxTimeDelta):
  global gKeepAliveType
  global gTotalLines
  global gMaxTimeDeltaDiff
  global gMinTimeDeltaDiff

  if (os.path.isfile(logfile)):
    file = open(logfile, 'r')
    print("") 
    sys.stdout.write("Creating time delta profile from logfile: %s, please wait...processing line: " % logfile)
    if (gKeepAliveType == "lines"):
      # if we are showing the lines processed keep alive, make an initial
      # pass of the file so we can sount the total number of lines
      gTotalLines = 0
      for line in file:
        gTotalLines += 1
      file.seek(0)
    numLines = 0
    currLine = ""
    currTimestampStr = ""
    currLineNum = 1
    numCounts = 0
    gMaxTimeDeltaDiff = 0.0
    gMinTimeDeltaDiff = sys.float_info.max
    numDisplayed = 0
    for line in file:
      printKeepAlive(numLines, gKeepAliveType)
      numLines += 1
      if (findApp(line) == True):
        timestamp = findTimestamp(line)
        if (timestamp != ""):
          prevLineNum = currLineNum
          currLineNum = numLines
          prevLine = currLine
          currLine = line
          prevTimestampStr = currTimestampStr
          currTimestampStr = timestamp
          if (prevTimestampStr != ""):
            currTimestamp = datetime.datetime.strptime(currTimestampStr, gTimestampFormat)
            prevTimestamp = datetime.datetime.strptime(prevTimestampStr, gTimestampFormat)
            timestampDiff = timeDeltaToSec(currTimestamp - prevTimestamp)
            if (timestampDiff >= maxTimeDelta):
              numCounts += 1
              if (timestampDiff > gMaxTimeDeltaDiff):
                gMaxTimeDeltaDiff = timestampDiff
              if (timestampDiff < gMinTimeDeltaDiff):
                gMinTimeDeltaDiff = timestampDiff
              gProfiles1.append({"lineNum1":prevLineNum,
                                 "line1":prevLine.strip(),
                                 "lineNum2":currLineNum,
                                 "line2":currLine.strip(),
                                 "delta":timestampDiff})
    print("")
    return (True)
  else:
    print("ERROR: logfile: '%s' not found..." % logfile)
    return (False)

#######################################################
#
# show all areas whose time delta is >= specified time
#
#######################################################
def showDelta(logfile, outfile, option, count, maxTimeDelta):
  global gAppFilter
  global gNoFilter
  global gProfiles1
  global gMaxTimeDeltaDiff
  global gMinTimeDeltaDiff

  # see if we need to sort our profile
  if (option == "-max"):
    gProfiles1.sort(key=operator.itemgetter('delta'), reverse=True)
  elif (option == "-min"):
    gProfiles1.sort(key=operator.itemgetter('delta'), reverse=False)
  maxTimeDeltaDiff = 0.0
  minTimeDeltaDiff = sys.float_info.max
  if (outfile == "none"):
    outfile = sys.stdout
  else:
    outfile = open(outfile, "w+")
  numDisplayed = 0
  outfile.write("\n")
  outfile.write("LOGFILE TIME DELTA PROFILE:\n")
  outfile.write("================================\n")
  outfile.write("Logfile          : %s\n" % (logfile))
  outfile.write("Time Delta (Sec) : %f\n" % (maxTimeDelta))
  for profile in gProfiles1:
    if ((count == gDisplayAll) or (numDisplayed < int(count))):
      outfile.write("\n")
      outfile.write("Time Delta (sec): %f\n" % profile["delta"])
      outfile.write("===============================\n")
      outfile.write("%s%d:%s %s\n" % (gHighlight, profile["lineNum1"], gNormal, profile["line1"]))
      outfile.write("%s%d:%s %s\n" % (gHighlight, profile["lineNum2"], gNormal, profile["line2"]))
      numDisplayed += 1
      if (profile["delta"] > maxTimeDeltaDiff):
        maxTimeDeltaDiff = profile["delta"]
      if (profile["delta"] < minTimeDeltaDiff):
        minTimeDeltaDiff = profile["delta"]
  if (gAppFilter != gNoFilter):
    logfile = logfile + "(" + gAppFilter + ")"
  outfile.write("\n")
  outfile.write("\n")
  outfile.write("RESULTS SUMMARY:\n")
  outfile.write("=========================================\n")
  outfile.write("Logfile                   : %s\n" % (logfile))
  outfile.write("Time Delta (sec)          : %f\n" % maxTimeDelta)
  if (gMaxTimeDeltaDiff > 0.0):
    outfile.write("Total Max Delta (sec)     : %f\n" % gMaxTimeDeltaDiff)
    outfile.write("Displayed Max Delta (sec) : %f\n" % maxTimeDeltaDiff)
    outfile.write("Total Min Delta (sec)     : %f\n" % gMinTimeDeltaDiff)
    outfile.write("Displayed Min Delta (sec) : %f\n" % minTimeDeltaDiff)
  outfile.write("Total Areas               : %d\n" % len(gProfiles1))
  outfile.write("Displayed Areas           : %d\n" % numDisplayed)
  outfile.write("\n")

#####################################################
#
# find the first valid file in the arg list
#
#####################################################
def findFirstFileArg(args):
  index = 1
  for arg in sys.argv[index:]:
    if (os.path.isfile(arg)):
      break
    index += 1
  return index

##############################
#
# start of main program
#
##############################
if (__name__ == '__main__'):

  # set default command line args
  outfile = "none"
  filter = "none"
  filterParmNeeded = False
  option = gNoOption
  count = gDisplayAll
  fileFilter = gNoFilter
  functionFilter = gNoFilter
  gAppFilter = gNoFilter
  gDiffType = gValidDiffs[0]
  deltaRequested = False

  # validate usage and create profile
  if ((len(sys.argv) < 2) or ((len(sys.argv)) == 2) and (sys.argv[1] == "-h")):
    showUsage()
  else:
    firstFileArg = findFirstFileArg(sys.argv)
    if (firstFileArg < len(sys.argv)):
      for arg in sys.argv[1:firstFileArg]:
        if (arg in gValidOptions):
          option = arg
        else:
          tokens = arg.split("=")
          if (len(tokens) == 2):
            filter = tokens[0].strip()
            parm = tokens[1].strip()
            if (filter == "file"):
              fileFilter = parm
            elif (filter == "app"):
              gAppFilter = parm
            elif (filter == "func"):
              functionFilter = parm
            elif (filter == "num"):
              count = parm
            elif (filter == "out"):
              outfile = parm
            elif (filter == "delta"):
              maxTimeDelta = parm
              deltaRequested = True
            elif ((filter == "diff") and (parm in gValidDiffs) and ((firstFileArg+2) == len(sys.argv))):
              gDiffType = parm
              gDiffRequested = True
            else:
              showUsage()
          else:
            showUsage()
      if (gDiffRequested):
        # diff two profiles
        logfile1 = sys.argv[firstFileArg]
        logfile2 = sys.argv[firstFileArg+1]
        if ((createProfile(logfile1, gProfiles1)) and (createProfile(logfile2, gProfiles2))):
          diffProfiles(gProfiles1, gProfiles2)
          showProfile("Diff: %s->%s" % (logfile1, logfile2), outfile, option, count, fileFilter, functionFilter, gProfilesDiff)
      elif (deltaRequested):
        # find all areas that exceed the specified time delta
        if (createDelta(sys.argv[firstFileArg], float(maxTimeDelta))):
          showDelta(sys.argv[firstFileArg], outfile, option, count, float(maxTimeDelta))
      else:
        # normal profile(s)
        for arg in sys.argv[firstFileArg:]:
          logfile = arg
          gProfiles1 = []
          if (createProfile(logfile, gProfiles1)):
            showProfile(logfile, outfile, option, count, fileFilter, functionFilter, gProfiles1)
    else:
      print("ERROR: logfile: '%s' not found..." % sys.argv[firstFileArg-1])
